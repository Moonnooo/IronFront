<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pixel Front â€“ Combat Math Prototype</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      background: #0f0f0f;
      color: #e6e6e6;
      font-family: monospace;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    #container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    canvas {
      image-rendering: pixelated;
      border: 2px solid #333;
      background: #111;
    }

    #ui {
      margin-top: 12px;
      width: 100%;
      max-width: 1024px;
      text-align: center;
    }

    #balanceBar {
      height: 16px;
      width: 100%;
      background: #222;
      border: 1px solid #333;
      position: relative;
    }

    #balanceFill {
      height: 100%;
      width: 0%;
      transition: width 0.2s linear, background-color 0.2s linear;
    }

    #balanceValue {
      font-size: 12px;
      margin-top: 4px;
    }
  </style>
</head>
<body>
<div id="container">
  <canvas id="game" width="1024" height="1024"></canvas>
  <div id="ui">
    <div id="balanceBar"><div id="balanceFill"></div></div>
    <div id="balanceValue"></div>
  </div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const TILE_SIZE = 16;
const GRID_SIZE = 64;

// ===== Economy =====
const MAX_BALANCE = 200;
const BALANCE_REGEN = 6;
let balance = MAX_BALANCE;

const balanceFill = document.getElementById('balanceFill');
const balanceValue = document.getElementById('balanceValue');

// ===== Terrain =====
const TERRAIN = {
  plains: { color: '#2e5f2e', moveCost: 1, defense: 1 },
  forest: { color: '#1f4f3a', moveCost: 2, defense: 1.3 },
  mountain: { color: '#555', moveCost: 4, defense: 2 }
};

function randomTerrain() {
  const r = Math.random();
  if (r < 0.6) return 'plains';
  if (r < 0.85) return 'forest';
  return 'mountain';
}

// ===== Grid =====
const grid = [];
for (let y = 0; y < GRID_SIZE; y++) {
  grid[y] = [];
  for (let x = 0; x < GRID_SIZE; x++) {
    grid[y][x] = {
      owner: 'neutral',
      terrain: randomTerrain(),
      army: 0
    };
  }
}

// Start positions
grid[32][32].owner = 'player';
grid[32][32].army = 20;

grid[10][10].owner = 'ai';
grid[10][10].army = 20;

// ===== Drawing =====
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      const tile = grid[y][x];

      ctx.fillStyle = TERRAIN[tile.terrain].color;
      ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);

      if (tile.owner === 'player') ctx.fillStyle = 'rgba(76,175,80,0.6)';
      else if (tile.owner === 'ai') ctx.fillStyle = 'rgba(244,67,54,0.6)';
      else continue;

      ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);

      if (tile.army > 0) {
        ctx.fillStyle = '#fff';
        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(
          tile.army > 99 ? '99+' : tile.army,
          x*TILE_SIZE + TILE_SIZE/2,
          y*TILE_SIZE + TILE_SIZE/2
        );
      }
    }
  }

  updateBalanceUI();
}

function updateBalanceUI() {
  const pct = balance / MAX_BALANCE;
  balanceFill.style.width = `${pct*100}%`;
  balanceValue.textContent = `Balance: ${Math.floor(balance)}`;

  balanceFill.style.backgroundColor = pct > 0.66 ? '#4caf50'
    : pct > 0.33 ? '#ffc107' : '#f44336';
}

// ===== Combat Math =====
function resolveCombat(attacker, defender, terrain) {
  const defenseMultiplier = TERRAIN[terrain].defense;
  const effectiveDefense = defender * defenseMultiplier;

  const loss = Math.min(attacker, Math.ceil(effectiveDefense * 0.6));
  const remainingAttack = attacker - loss;

  return {
    attackerRemaining: Math.max(0, remainingAttack),
    defenderRemaining: Math.max(0, defender - Math.ceil(attacker * 0.5))
  };
}

// ===== Expansion / Attack =====
function expandOrAttack(owner, direction) {
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {
      const tile = grid[y][x];
      if (tile.owner !== owner || tile.army < 2) continue;

      let nx = x, ny = y;
      if (direction === 'up') ny--;
      if (direction === 'down') ny++;
      if (direction === 'left') nx--;
      if (direction === 'right') nx++;
      if (!grid[ny] || !grid[ny][nx]) continue;

      const target = grid[ny][nx];
      const moveCost = TERRAIN[target.terrain].moveCost;

      if (owner === 'player' && balance < moveCost) return;

      const attackingForce = Math.floor(tile.army / 2);

      if (target.owner === 'neutral') {
        tile.army -= attackingForce;
        target.owner = owner;
        target.army = attackingForce;
        if (owner === 'player') balance -= moveCost;
      } else if (target.owner !== owner) {
        const result = resolveCombat(attackingForce, target.army, target.terrain);
        tile.army -= attackingForce;
        target.army = result.defenderRemaining;

        if (result.attackerRemaining > result.defenderRemaining) {
          target.owner = owner;
          target.army = result.attackerRemaining;
        }

        if (owner === 'player') balance -= moveCost * 2;
      }

      return; // one action per click/tick
    }
  }
}

function getDirectionFromClick(e) {
  const r = canvas.getBoundingClientRect();
  const cx = r.left + r.width/2;
  const cy = r.top + r.height/2;
  const dx = e.clientX - cx;
  const dy = e.clientY - cy;
  return Math.abs(dx) > Math.abs(dy)
    ? dx > 0 ? 'right' : 'left'
    : dy > 0 ? 'down' : 'up';
}

canvas.addEventListener('mousedown', e => {
  expandOrAttack('player', getDirectionFromClick(e));
});

// ===== Economy Tick =====
setInterval(() => {
  balance = Math.min(MAX_BALANCE, balance + BALANCE_REGEN);
}, 1000);

// ===== AI =====
setInterval(() => {
  const dirs = ['up','down','left','right'];
  expandOrAttack('ai', dirs[Math.floor(Math.random()*dirs.length)]);
}, 1500);

function gameLoop() {
  draw();
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
